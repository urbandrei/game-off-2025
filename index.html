<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tides of War</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
        }

        #gameContainer {
            position: relative;
            background: #000;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        // ===== GAME CONSTANTS =====
        const GAME_WIDTH = 1280;
        const GAME_HEIGHT = 720;
        const ASPECT_RATIO = GAME_WIDTH / GAME_HEIGHT;

        // Game States
        const STATE = {
            START: 'START',
            TUTORIAL: 'TUTORIAL',
            PLAYING: 'PLAYING',
            SHOP: 'SHOP',
            PAUSED: 'PAUSED',
            GAME_OVER: 'GAME_OVER'
        };

        // ===== CANVAS SETUP =====
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const windowRatio = windowWidth / windowHeight;

            let width, height;

            if (windowRatio > ASPECT_RATIO) {
                height = windowHeight;
                width = height * ASPECT_RATIO;
            } else {
                width = windowWidth;
                height = width / ASPECT_RATIO;
            }

            container.style.width = width + 'px';
            container.style.height = height + 'px';
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ===== AUDIO SYSTEM =====
        // Simple base64 audio generation using Web Audio API
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playTone(frequency, duration, type = 'sine', volume = 0.3) {
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.type = type;
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            gainNode.gain.setValueAtTime(volume, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        const sounds = {
            cannonFire: () => playTone(100, 0.2, 'sawtooth', 0.4),
            impact: () => playTone(150, 0.1, 'square', 0.3),
            wavecrash: () => playTone(80, 0.5, 'sine', 0.2),
            pickup: () => playTone(600, 0.1, 'sine', 0.3),
            coin: () => {
                playTone(800, 0.05, 'sine', 0.3);
                setTimeout(() => playTone(1000, 0.05, 'sine', 0.3), 50);
            },
            scuttle: () => playTone(200, 0.05, 'square', 0.15),
            button: () => playTone(400, 0.05, 'square', 0.2),
            ultimate: () => {
                playTone(200, 0.3, 'sawtooth', 0.5);
                setTimeout(() => playTone(400, 0.3, 'sawtooth', 0.5), 100);
            },
            chainBreak: () => playTone(300, 0.15, 'square', 0.3)
        };

        // ===== GAME STATE =====
        let gameState = STATE.START;
        let currentWave = 0;
        let currentDay = 1;
        let currentTime = 6; // Start at 6:00 AM
        let sandDollars = 0;
        let castleHP = 100;
        let maxCastleHP = 100;
        let ultimateCharge = 0;
        let ultimateMaxCharge = 10;
        let highScore = parseInt(localStorage.getItem('tidesOfWarHighScore')) || 0;
        let tutorialShown = localStorage.getItem('tidesOfWarTutorial') === 'true';
        let tutorialEnabled = localStorage.getItem('tidesOfWarTutorialEnabled') !== 'false'; // Default true

        // Upgrades
        let upgrades = {
            cannonCooldown: 0,
            blastRadius: 0,
            castleHealth: 0,
            ultimateCharge: 0,
            ultimateDamage: 0,
            dragSpeed: 0,
            objectValue: 0,
            maxTethers: 0
        };

        // Cannon
        let cannonCooldown = 0;
        let cannonMaxCooldown = 1.0;
        let blastRadius = 25;

        // Drag system
        let draggedObjects = [];
        let maxTethers = 1;
        let lastClickPos = {x: 0, y: 0};
        let dragStartPos = {x: 0, y: 0};
        let objectDragSpeed = 0.2;
        let tetheredDragSpeed = 0.1; // Slower speed for tethered items
        let objectValueMultiplier = 1.0;

        // Game entities
        let crabs = [];
        let objects = [];
        let particles = [];
        let explosions = [];
        let floatingTexts = [];

        // Wave system
        let waveAnimating = false;
        let waveAnimTimer = 0;
        let timeSinceLastWave = 0;
        let waveEntitiesSpawned = false;
        let tideHeight = 0.4; // Percentage of screen
        let waveTime = 0; // For wave edge animation
        let previousRestingY = GAME_HEIGHT * 0.6; // Track previous tide position
        let currentWaterColorRGB = {r: 30, g: 58, b: 95}; // Start with night water color
        let currentSkyColorRGB = {r: 45, g: 45, b: 110}; // Start with night sky color

        // Wave rendering configuration
        const waveConfig = {
            waveSpeed: 0.0133, // 33% slower than original
            waveLength: 0.01,
            waveAmplitude: 10,
            lightBlueOffset: 35,
            foamOffset: 70,
            surgeCompression: 0.25,
            expansionDuration: 0.5, // seconds
            surgeDuration: 1.0, // seconds
            retreatDarkDuration: 1.0, // seconds (fastest)
            retreatLightDuration: 1.75, // seconds (medium)
            retreatFoamDuration: 2.75 // seconds (slowest)
        };

        // Tutorial
        let tutorialStep = 0;
        let tutorialTimer = 0;

        // Input
        let mouse = {x: 0, y: 0, down: false, clicked: false};
        let keys = {};

        // ===== INPUT HANDLING =====
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = (e.clientX - rect.left) * (GAME_WIDTH / rect.width);
            mouse.y = (e.clientY - rect.top) * (GAME_HEIGHT / rect.height);
        });

        canvas.addEventListener('mousedown', (e) => {
            mouse.down = true;
            mouse.clicked = true;
        });

        canvas.addEventListener('mouseup', (e) => {
            mouse.down = false;
            if (draggedObjects.length > 0) {
                draggedObjects = [];
            }
        });

        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            if (e.key === ' ' && gameState === STATE.PLAYING) {
                e.preventDefault();
                if (ultimateCharge >= ultimateMaxCharge) {
                    activateUltimate();
                }
            }

            if (e.key === 'Escape' && gameState === STATE.PLAYING) {
                gameState = STATE.PAUSED;
            } else if (e.key === 'Escape' && gameState === STATE.PAUSED) {
                gameState = STATE.PLAYING;
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // ===== HELPER FUNCTIONS =====
        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function lerp(start, end, t) {
            return start + (end - start) * t;
        }

        function easeOutSine(x) {
            return Math.sin((x * Math.PI) / 2);
        }

        function easeInSine(x) {
            return 1 - Math.cos((x * Math.PI) / 2);
        }

        function easeInOutSine(x) {
            return -(Math.cos(Math.PI * x) - 1) / 2;
        }

        function drawWavyLayer(color, baseY, offset, speedMod, phaseOffset) {
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(0, GAME_HEIGHT);
            for (let x = 0; x <= GAME_WIDTH; x++) {
                const y = (baseY - offset) + Math.sin(x * waveConfig.waveLength + waveTime * speedMod + phaseOffset) * waveConfig.waveAmplitude;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(GAME_WIDTH, GAME_HEIGHT);
            ctx.closePath();
            ctx.fill();
        }

        function calculateWavePositions() {
            // Calculate resting water Y position based on tide
            const restingY = GAME_HEIGHT * (1 - tideHeight * 0.6);

            // Dynamic peakY based on tide height
            // High tide (0.85): peakY = 15% of screen (near top)
            // Low tide (0.15): peakY = 60% of screen (below middle)
            const normalizedTide = (tideHeight - 0.15) / (0.85 - 0.15);
            const peakY = GAME_HEIGHT * lerp(0.60, 0.15, Math.max(0, Math.min(1, normalizedTide)));

            const offScreenY = GAME_HEIGHT + 200;

            let surgeY = offScreenY;
            let isSurging = waveAnimating && waveAnimTimer < waveConfig.surgeDuration;
            let currentCompression = 1.0;

            if (isSurging) {
                // Surge phase - wave rising to peak
                const p = waveAnimTimer / waveConfig.surgeDuration;
                const easedP = easeOutSine(p);
                surgeY = offScreenY - ((offScreenY - peakY) * easedP);
                currentCompression = waveConfig.surgeCompression;
            } else if (waveAnimating) {
                // Post-surge - calculate expansion and retreat
                const timeSincePeak = waveAnimTimer - waveConfig.surgeDuration;

                // Calculate compression (expansion phase)
                if (timeSincePeak < waveConfig.expansionDuration) {
                    let p = timeSincePeak / waveConfig.expansionDuration;
                    p = easeInOutSine(p);
                    currentCompression = waveConfig.surgeCompression + (p * (1 - waveConfig.surgeCompression));
                } else {
                    currentCompression = 1.0;
                }

                // Helper to calculate retreat position for each layer
                function getLayerY(duration) {
                    if (timeSincePeak > duration) return restingY;
                    const p = timeSincePeak / duration;
                    const easedP = easeInSine(p);
                    return peakY + ((restingY - peakY) * easedP);
                }

                surgeY = peakY; // Not used in retreat, but set for completeness
            }

            return {
                restingY,
                peakY,
                offScreenY,
                surgeY,
                isSurging,
                currentCompression,
                darkBlueY: isSurging ? surgeY : (waveAnimating ?
                    (waveAnimTimer - waveConfig.surgeDuration > waveConfig.retreatDarkDuration ? restingY :
                     peakY + ((restingY - peakY) * easeInSine((waveAnimTimer - waveConfig.surgeDuration) / waveConfig.retreatDarkDuration))) :
                    restingY),
                lightBlueY: isSurging ? surgeY : (waveAnimating ?
                    (waveAnimTimer - waveConfig.surgeDuration > waveConfig.retreatLightDuration ? restingY :
                     peakY + ((restingY - peakY) * easeInSine((waveAnimTimer - waveConfig.surgeDuration) / waveConfig.retreatLightDuration))) :
                    restingY),
                foamY: isSurging ? surgeY : (waveAnimating ?
                    (waveAnimTimer - waveConfig.surgeDuration > waveConfig.retreatFoamDuration ? restingY :
                     peakY + ((restingY - peakY) * easeInSine((waveAnimTimer - waveConfig.surgeDuration) / waveConfig.retreatFoamDuration))) :
                    restingY)
            };
        }

        function getTideHeight() {
            // Sinusoidal wave pattern over 7 waves
            // Wave 4 is highest (high tide), Wave 7 is lowest (low tide/shop)
            const waveInCycle = ((currentWave - 1) % 7) + 1;

            // Phase shift: wave 4 = peak, wave 1&7 = trough
            const waveRadians = ((waveInCycle - 1) / 7) * Math.PI * 2 + Math.PI;
            const tideValue = Math.cos(waveRadians);

            // Map from -1...1 to 0.15...0.85 (dramatic range)
            return 0.5 + tideValue * 0.35;
        }

        function getSkyColor() {
            // Day at high tide, night at low tide
            // tideHeight ranges from ~0.15 (low tide) to ~0.85 (high tide)
            // Use tideHeight to determine day/night
            if (tideHeight > 0.5) {
                // High tide = Day
                if (tideHeight < 0.6) {
                    // Dawn
                    const t = (tideHeight - 0.5) / 0.1;
                    return lerpColor('#2d2d6e', '#87ceeb', t);
                } else if (tideHeight > 0.75) {
                    // Peak day
                    return '#87ceeb'; // Light blue
                } else {
                    return '#87ceeb'; // Light blue
                }
            } else {
                // Low tide = Night
                if (tideHeight > 0.4) {
                    // Dusk
                    const t = (0.5 - tideHeight) / 0.1;
                    return lerpColor('#87ceeb', '#ff9a7a', t);
                } else {
                    return '#2d2d6e'; // Dark blue night
                }
            }
        }

        function getWaterColor() {
            // Day at high tide, night at low tide
            if (tideHeight > 0.5) {
                return '#6fb3d2'; // Light cyan (day)
            } else {
                return '#1e3a5f'; // Deep navy (night)
            }
        }

        function lerpColor(color1, color2, t) {
            const r1 = parseInt(color1.slice(1, 3), 16);
            const g1 = parseInt(color1.slice(3, 5), 16);
            const b1 = parseInt(color1.slice(5, 7), 16);

            const r2 = parseInt(color2.slice(1, 3), 16);
            const g2 = parseInt(color2.slice(3, 5), 16);
            const b2 = parseInt(color2.slice(5, 7), 16);

            const r = Math.round(lerp(r1, r2, t));
            const g = Math.round(lerp(g1, g2, t));
            const b = Math.round(lerp(b1, b2, t));

            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        function hexToRGB(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return {r, g, b};
        }

        function rgbToHex(rgb) {
            const r = Math.round(rgb.r).toString(16).padStart(2, '0');
            const g = Math.round(rgb.g).toString(16).padStart(2, '0');
            const b = Math.round(rgb.b).toString(16).padStart(2, '0');
            return `#${r}${g}${b}`;
        }

        function lerpRGB(rgb1, rgb2, t) {
            return {
                r: lerp(rgb1.r, rgb2.r, t),
                g: lerp(rgb1.g, rgb2.g, t),
                b: lerp(rgb1.b, rgb2.b, t)
            };
        }

        // ===== GAME ENTITIES =====
        class Crab {
            constructor(type, x, y) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.speed = 25;
                this.maxHP = 25;
                this.hp = 25;
                this.size = 15;
                this.stunned = false;
                this.stunnedTimer = 0;
                this.animFrame = 0;
                this.animTimer = 0;
                this.atCastle = false;
                this.fleeing = false;

                // Type-specific properties
                switch(type) {
                    case 'tank':
                        this.maxHP = this.hp = 100;
                        this.speed = 15;
                        this.size = 30;
                        this.color = '#d64545';
                        break;
                    case 'fast':
                        this.maxHP = this.hp = 20;
                        this.speed = 50;
                        this.size = 10;
                        this.color = '#ff6b9d';
                        break;
                    case 'armored':
                        this.maxHP = this.hp = 60;
                        this.speed = 20;
                        this.size = 18;
                        this.armor = 0.5;
                        this.color = '#7d5ba6';
                        break;
                    case 'treasure':
                        this.maxHP = this.hp = 40;
                        this.speed = -30; // Moves away
                        this.size = 13;
                        this.color = '#ffd700';
                        this.shellValue = Math.floor(Math.random() * 61) + 40; // 40-100
                        break;
                    case 'boss':
                        this.maxHP = this.hp = 300;
                        this.speed = 10;
                        this.size = 60;
                        this.color = '#8b0000';
                        break;
                    default:
                        this.color = '#ff6b4a';
                }
            }

            update(dt) {
                if (this.fleeing) {
                    this.y += this.speed * 2 * dt;
                    if (this.y > GAME_HEIGHT) {
                        return false; // Remove
                    }
                    return true;
                }

                if (this.stunned) {
                    this.stunnedTimer -= dt;
                    if (this.stunnedTimer <= 0) {
                        this.stunned = false;
                    }
                    return true;
                }

                // Move toward castle (upward)
                this.y -= this.speed * dt;

                // Animation
                this.animTimer += dt;
                if (this.animTimer > 0.2) {
                    this.animTimer = 0;
                    this.animFrame = (this.animFrame + 1) % 2;
                }

                // Check if reached castle
                if (this.y < 80) {
                    this.atCastle = true;
                    this.y = 80;
                }

                return true;
            }

            damage(amount) {
                if (this.armor) {
                    amount *= (1 - this.armor);
                }
                this.hp -= amount;
                if (this.hp <= 0) {
                    if (this.type === 'treasure') {
                        // Drop shell
                        objects.push(new GameObject('shell', this.x, this.y, this.shellValue));
                    }
                    this.fleeing = true;
                    this.hp = 1; // Keep alive until off screen
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);

                switch(this.type) {
                    case 'basic':
                        // Dungeness crab - wide oval body
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, this.size * 0.7, this.size * 0.5, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Claws (wide, flat)
                        const clawOffset = this.animFrame === 0 ? 2 : -2;
                        ctx.fillRect(-this.size - 6, clawOffset - 3, 8, 6);
                        ctx.fillRect(this.size - 2, clawOffset - 3, 8, 6);

                        // Eyes on stalks
                        ctx.fillStyle = '#fff';
                        ctx.fillRect(-this.size/3 - 2, -this.size/2 - 6, 4, 7);
                        ctx.fillRect(this.size/3 - 2, -this.size/2 - 6, 4, 7);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(-this.size/3 - 1, -this.size/2 - 7, 3, 3);
                        ctx.fillRect(this.size/3 - 1, -this.size/2 - 7, 3, 3);
                        break;

                    case 'tank':
                    case 'treasure':
                        // Hermit crab with spiral shell
                        ctx.fillStyle = this.type === 'treasure' ? '#ffd700' : '#d64545';
                        ctx.beginPath();
                        ctx.arc(0, -this.size/4, this.size * 0.6, 0, Math.PI * 2);
                        ctx.fill();

                        // Spiral pattern on shell
                        ctx.fillStyle = this.type === 'treasure' ? '#ffed4e' : '#ff8787';
                        ctx.beginPath();
                        ctx.arc(-this.size/6, -this.size/3, this.size * 0.25, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(this.size/8, -this.size/5, this.size * 0.15, 0, Math.PI * 2);
                        ctx.fill();

                        // Body sticking out (small)
                        ctx.fillStyle = '#ff9966';
                        ctx.fillRect(-this.size/3, this.size/4, this.size * 0.6, this.size/3);

                        // Small claws
                        const hClawOffset = this.animFrame === 0 ? 1 : -1;
                        ctx.fillRect(-this.size/2 - 3, this.size/3 + hClawOffset, 5, 3);
                        ctx.fillRect(this.size/2 - 2, this.size/3 + hClawOffset, 5, 3);

                        // Eyes
                        ctx.fillStyle = '#000';
                        ctx.fillRect(-this.size/4 - 1, this.size/4, 2, 2);
                        ctx.fillRect(this.size/4 - 1, this.size/4, 2, 2);
                        break;

                    case 'fast':
                        // Conical shell (like a snail/cone shell)
                        ctx.fillStyle = this.color;
                        ctx.beginPath();
                        ctx.moveTo(0, -this.size);
                        ctx.lineTo(this.size/2, this.size/2);
                        ctx.lineTo(-this.size/2, this.size/2);
                        ctx.closePath();
                        ctx.fill();

                        // Spiral stripes on cone
                        ctx.fillStyle = '#ffb3d9';
                        for (let i = 0; i < 3; i++) {
                            const y = -this.size + (i * this.size/2);
                            const w = (this.size/2) * (1 - i/3);
                            ctx.fillRect(-w/2, y, w, 2);
                        }

                        // Small body at base
                        ctx.fillStyle = '#ff9999';
                        ctx.fillRect(-this.size/4, this.size/2 - 3, this.size/2, 5);

                        // Tiny eyes
                        ctx.fillStyle = '#000';
                        ctx.fillRect(-this.size/6, this.size/2 - 2, 2, 2);
                        ctx.fillRect(this.size/6 - 2, this.size/2 - 2, 2, 2);
                        break;

                    case 'armored':
                        // Similar to basic but with armor plates
                        ctx.fillStyle = this.color;
                        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);

                        // Armor plates
                        ctx.fillStyle = '#9d7bc6';
                        for (let i = 0; i < 3; i++) {
                            const y = -this.size/2 + (i * this.size/3);
                            ctx.fillRect(-this.size/2 + 2, y + 1, this.size - 4, this.size/4);
                        }

                        // Eyes
                        ctx.fillStyle = '#fff';
                        const aEyeOffset = this.size / 4;
                        ctx.fillRect(-aEyeOffset - 2, -aEyeOffset, 4, 4);
                        ctx.fillRect(aEyeOffset - 2, -aEyeOffset, 4, 4);
                        ctx.fillStyle = '#000';
                        ctx.fillRect(-aEyeOffset - 1, -aEyeOffset + 1, 2, 2);
                        ctx.fillRect(aEyeOffset - 1, -aEyeOffset + 1, 2, 2);

                        // Claws
                        const aClawOffset = this.animFrame === 0 ? 2 : -2;
                        ctx.fillStyle = this.color;
                        ctx.fillRect(-this.size/2 - 6, aClawOffset, 6, 6);
                        ctx.fillRect(this.size/2, aClawOffset, 6, 6);
                        break;

                    case 'boss':
                        // Giant spider crab - long legs, round body
                        ctx.fillStyle = this.color;

                        // Body (round)
                        ctx.beginPath();
                        ctx.arc(0, 0, this.size * 0.5, 0, Math.PI * 2);
                        ctx.fill();

                        // Long spider legs (4 pairs)
                        ctx.strokeStyle = this.color;
                        ctx.lineWidth = 2;
                        for (let i = 0; i < 4; i++) {
                            const angle = (i / 4) * Math.PI - Math.PI/2;
                            const legLength = this.size * 1.2;
                            const bendOffset = this.animFrame === 0 ? 5 : -5;

                            // Left legs
                            ctx.beginPath();
                            ctx.moveTo(-this.size/2, 0);
                            ctx.lineTo(-this.size/2 + Math.cos(angle - 0.5) * legLength/2, Math.sin(angle - 0.5) * legLength/2 + bendOffset);
                            ctx.lineTo(-this.size/2 + Math.cos(angle - 0.3) * legLength, Math.sin(angle - 0.3) * legLength);
                            ctx.stroke();

                            // Right legs
                            ctx.beginPath();
                            ctx.moveTo(this.size/2, 0);
                            ctx.lineTo(this.size/2 + Math.cos(angle + 0.5) * legLength/2, Math.sin(angle + 0.5) * legLength/2 + bendOffset);
                            ctx.lineTo(this.size/2 + Math.cos(angle + 0.3) * legLength, Math.sin(angle + 0.3) * legLength);
                            ctx.stroke();
                        }

                        // Eyes (multiple small eyes)
                        ctx.fillStyle = '#ff0000';
                        for (let i = 0; i < 6; i++) {
                            const angle = (i / 6) * Math.PI * 2;
                            const eyeX = Math.cos(angle) * this.size/4;
                            const eyeY = Math.sin(angle) * this.size/4;
                            ctx.fillRect(eyeX - 2, eyeY - 2, 3, 3);
                        }
                        break;

                    default:
                        // Fallback to original design
                        ctx.fillStyle = this.color;
                        ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);

                        ctx.fillStyle = '#fff';
                        const defEyeOffset = this.size / 4;
                        ctx.fillRect(-defEyeOffset - 2, -defEyeOffset, 4, 4);
                        ctx.fillRect(defEyeOffset - 2, -defEyeOffset, 4, 4);

                        ctx.fillStyle = '#000';
                        ctx.fillRect(-defEyeOffset - 1, -defEyeOffset + 1, 2, 2);
                        ctx.fillRect(defEyeOffset - 1, -defEyeOffset + 1, 2, 2);

                        ctx.fillStyle = this.color;
                        const defClawOffset = this.animFrame === 0 ? 2 : -2;
                        ctx.fillRect(-this.size/2 - 6, defClawOffset, 6, 6);
                        ctx.fillRect(this.size/2, defClawOffset, 6, 6);
                }

                // Stun stars (applies to all types)
                if (this.stunned) {
                    ctx.fillStyle = '#ffff00';
                    const starAngle = Date.now() / 200;
                    for (let i = 0; i < 3; i++) {
                        const angle = starAngle + (i * Math.PI * 2 / 3);
                        const sx = Math.cos(angle) * 15;
                        const sy = Math.sin(angle) * 10 - this.size/2 - 8;
                        ctx.fillRect(sx - 2, sy - 2, 4, 4);
                    }
                }

                ctx.restore();
            }
        }

        class GameObject {
            constructor(type, x, y, value = null) {
                this.type = type;
                this.x = x;
                this.y = y;
                this.bobTimer = Math.random() * Math.PI * 2;
                this.baseY = y;
                this.spawnWave = currentWave;

                switch(type) {
                    case 'bottle':
                        this.size = 8;
                        this.value = Math.floor(5 * objectValueMultiplier);
                        this.color = '#90ee90';
                        break;
                    case 'chest':
                        this.size = 13;
                        this.value = Math.floor(15 * objectValueMultiplier);
                        this.color = '#daa520';
                        break;
                    case 'treasure':
                        this.size = 18;
                        this.value = Math.floor(30 * objectValueMultiplier);
                        this.color = '#ff69b4';
                        break;
                    case 'shell':
                        this.size = 10;
                        this.value = value || 50;
                        this.color = '#ffd700';
                        break;
                }
            }

            update(dt) {
                this.bobTimer += dt * 2;
                this.y = this.baseY + Math.sin(this.bobTimer) * 3;
            }

            isHovered(mx, my) {
                return Math.abs(mx - this.x) < this.size && Math.abs(my - this.y) < this.size;
            }

            draw(ctx, hovered = false) {
                ctx.save();

                // Outline if hovered
                if (hovered) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x - this.size, this.y - this.size, this.size * 2, this.size * 2);
                }

                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);

                // Detail based on type
                if (this.type === 'bottle') {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(this.x - 3, this.y - this.size/2 + 2, 6, 3);
                } else if (this.type === 'chest') {
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(this.x - this.size/2, this.y, this.size, 3);
                    ctx.fillRect(this.x - 2, this.y - this.size/2, 4, this.size);
                }

                ctx.restore();
            }
        }

        class Particle {
            constructor(x, y, vx, vy, color, life = 1) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vy += 200 * dt; // Gravity
                this.life -= dt;
                return this.life > 0;
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
                ctx.globalAlpha = 1;
            }
        }

        class Explosion {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.timer = 0.3;
                this.maxTimer = 0.3;
            }

            update(dt) {
                this.timer -= dt;
                return this.timer > 0;
            }

            draw(ctx) {
                const progress = 1 - (this.timer / this.maxTimer);
                const size = blastRadius * 2 * progress; // Scale to match blast radius
                ctx.fillStyle = `rgba(255, 150, 0, ${1 - progress})`;
                ctx.fillRect(this.x - size/2, this.y - size/2, size, size);
                ctx.fillStyle = `rgba(255, 255, 100, ${1 - progress})`;
                ctx.fillRect(this.x - size/4, this.y - size/4, size/2, size/2);
            }
        }

        class FloatingText {
            constructor(x, y, text, color = '#ffff00') {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.timer = 1.5;
                this.maxTimer = 1.5;
            }

            update(dt) {
                this.y -= 30 * dt;
                this.timer -= dt;
                return this.timer > 0;
            }

            draw(ctx) {
                ctx.save();
                ctx.font = '16px "Press Start 2P"';
                ctx.fillStyle = this.color;
                ctx.textAlign = 'center';
                ctx.globalAlpha = this.timer / this.maxTimer;
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }

        // ===== GAME FUNCTIONS =====
        function startNewGame() {
            currentWave = 0;
            currentDay = 1;
            currentTime = 6;
            sandDollars = 0;
            castleHP = maxCastleHP;
            ultimateCharge = 0;
            crabs = [];
            objects = [];
            particles = [];
            explosions = [];
            floatingTexts = [];
            draggedObjects = [];

            upgrades = {
                cannonCooldown: 0,
                blastRadius: 0,
                castleHealth: 0,
                ultimateCharge: 0,
                ultimateDamage: 0,
                dragSpeed: 0,
                objectValue: 0,
                maxTethers: 0
            };

            applyUpgrades();

            if (tutorialEnabled && !tutorialShown) {
                gameState = STATE.TUTORIAL;
                tutorialStep = 0;
                tutorialTimer = 0;
            } else {
                gameState = STATE.PLAYING;
                startNextWave();
            }
        }

        function startNextWave() {
            currentWave++;
            currentTime = (currentTime + 1) % 24;
            tideHeight = getTideHeight();
            timeSinceLastWave = 0; // Reset wave timer

            // Increment day every 7 waves
            if (currentWave % 7 === 0) {
                currentDay++;
            }

            // Check for shop (every 7 waves, at low tide)
            if (currentWave % 7 === 0) {
                gameState = STATE.SHOP;
                return;
            }

            // Start wave animation
            waveAnimating = true;
            waveAnimTimer = 0;
            waveEntitiesSpawned = false;
            sounds.wavecrash();

            // Boss wave announcement
            if (currentWave % 10 === 0) {
                floatingTexts.push(new FloatingText(GAME_WIDTH/2, GAME_HEIGHT/2, 'BOSS WAVE!', '#ff0000'));
            }
        }

        function spawnWaveEntities() {
            // Calculate water resting position
            const waterY = GAME_HEIGHT * (1 - tideHeight * 0.6);

            // Calculate wave peak (20% above resting position)
            const wavePeakY = waterY * 0.8;

            // Spawn in the area between wave peak and resting position (top 20% of water)
            const spawnMinY = wavePeakY;
            const spawnMaxY = waterY;

            // Determine crab count (doubled for smaller, slower crabs)
            let crabCount = (3 + Math.floor(currentWave / 5)) * 2;

            // Spawn crabs
            for (let i = 0; i < crabCount; i++) {
                const x = Math.random() * (GAME_WIDTH - 100) + 50;
                const y = Math.random() * (spawnMaxY - spawnMinY) + spawnMinY;

                let type = 'basic';

                // Boss wave
                if (currentWave % 10 === 0 && i === 0) {
                    type = 'boss';
                } else {
                    // Determine type based on wave
                    const rand = Math.random();
                    if (currentWave >= 16 && rand < 0.2) {
                        type = 'armored';
                    } else if (currentWave >= 11 && rand < 0.15) {
                        type = 'treasure';
                    } else if (currentWave >= 11 && rand < 0.3) {
                        type = 'fast';
                    } else if (currentWave >= 6 && rand < 0.3) {
                        type = 'tank';
                    }
                }

                crabs.push(new Crab(type, x, y));
            }

            // Spawn objects (4-8 per wave, more for smaller objects)
            const objectCount = Math.floor(Math.random() * 5) + 4;
            for (let i = 0; i < objectCount; i++) {
                const x = Math.random() * (GAME_WIDTH - 100) + 50;
                const y = Math.random() * (spawnMaxY - spawnMinY) + spawnMinY;

                const rand = Math.random();
                let type = 'bottle';
                if (rand < 0.2) {
                    type = 'treasure';
                } else if (rand < 0.5) {
                    type = 'chest';
                }

                objects.push(new GameObject(type, x, y));
            }
        }

        function fireCannonball() {
            if (cannonCooldown > 0) return;

            cannonCooldown = cannonMaxCooldown;
            sounds.cannonFire();

            // Check hits - only count once per cannonball if ANY enemy is hit
            let hitAny = false;
            crabs.forEach(crab => {
                if (!crab.fleeing && distance(mouse.x, mouse.y, crab.x, crab.y) <= blastRadius) {
                    crab.damage(25);
                    hitAny = true;
                    sounds.impact();
                }
            });

            if (hitAny) {
                ultimateCharge = Math.min(ultimateCharge + 1, ultimateMaxCharge);
            }

            // Explosion
            explosions.push(new Explosion(mouse.x, mouse.y));

            // Particles
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 / 8) * i;
                const speed = 100 + Math.random() * 100;
                particles.push(new Particle(
                    mouse.x, mouse.y,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed - 50,
                    '#d2b48c',
                    0.5
                ));
            }
        }

        function checkTetherObjects() {
            // Store click position
            lastClickPos = {x: mouse.x, y: mouse.y};

            // Find all objects within blast radius
            const objectsInRange = objects.filter(obj => {
                return distance(lastClickPos.x, lastClickPos.y, obj.x, obj.y) <= blastRadius;
            });

            if (objectsInRange.length === 0) return;

            // Sort by distance (closest first)
            objectsInRange.sort((a, b) => {
                const distA = distance(lastClickPos.x, lastClickPos.y, a.x, a.y);
                const distB = distance(lastClickPos.x, lastClickPos.y, b.x, b.y);
                return distA - distB;
            });

            // Tether up to maxTethers objects
            const toTether = objectsInRange.slice(0, maxTethers);
            draggedObjects = toTether;

            if (draggedObjects.length > 0) {
                sounds.pickup();
            }
        }

        function activateUltimate() {
            ultimateCharge = 0;
            sounds.ultimate();

            const damage = 20 + upgrades.ultimateDamage * 10;

            crabs.forEach(crab => {
                if (!crab.fleeing) {
                    crab.stunned = true;
                    crab.stunnedTimer = 3;
                    crab.damage(damage);
                }
            });

            // Screen shake effect (visual feedback)
            floatingTexts.push(new FloatingText(GAME_WIDTH/2, 200, 'ULTIMATE!', '#ffff00'));
        }

        function applyUpgrades() {
            // Cannon cooldown
            cannonMaxCooldown = 1.0 - (upgrades.cannonCooldown * 0.15);

            // Blast radius
            blastRadius = 25 + (upgrades.blastRadius * 15);

            // Castle health (heals on purchase)
            maxCastleHP = 100 + (upgrades.castleHealth * 30);

            // Ultimate charge
            ultimateMaxCharge = 10 - upgrades.ultimateCharge;

            // Drag speed
            objectDragSpeed = 0.2 + (upgrades.dragSpeed * 0.05);

            // Object value
            objectValueMultiplier = 1.0 + (upgrades.objectValue * 0.2);

            // Max tethers
            maxTethers = 1 + upgrades.maxTethers;
        }

        function purchaseUpgrade(upgradeName) {
            const tier = upgrades[upgradeName];
            if (tier >= 5) return false;

            const cost = Math.floor(20 * Math.pow(1.8, tier));
            if (sandDollars < cost) return false;

            sandDollars -= cost;
            upgrades[upgradeName]++;

            if (upgradeName === 'castleHealth') {
                castleHP = maxCastleHP = 100 + (upgrades.castleHealth * 30);
            }

            applyUpgrades();
            sounds.coin();
            return true;
        }

        // ===== UPDATE LOOP =====
        function update(dt) {
            // Update cooldown
            if (cannonCooldown > 0) {
                cannonCooldown = Math.max(0, cannonCooldown - dt);
            }

            // Update wave edge animation
            waveTime += waveConfig.waveSpeed;

            // Gradual color transitions
            const targetWaterColor = hexToRGB(getWaterColor());
            const targetSkyColor = hexToRGB(getSkyColor());
            const colorLerpSpeed = 0.02; // Slow smooth transition

            currentWaterColorRGB = lerpRGB(currentWaterColorRGB, targetWaterColor, colorLerpSpeed);
            currentSkyColorRGB = lerpRGB(currentSkyColorRGB, targetSkyColor, colorLerpSpeed);

            // Wave animation
            if (waveAnimating) {
                waveAnimTimer += dt;

                // Total animation duration
                const totalDuration = waveConfig.surgeDuration + waveConfig.expansionDuration + waveConfig.retreatFoamDuration;

                // Spawn entities at wave peak (end of surge)
                if (waveAnimTimer >= waveConfig.surgeDuration && !waveEntitiesSpawned) {
                    spawnWaveEntities();
                    waveEntitiesSpawned = true;
                }

                if (waveAnimTimer >= totalDuration) {
                    waveAnimating = false;
                    // Update previous resting Y for next wave
                    const wavePos = calculateWavePositions();
                    previousRestingY = wavePos.restingY;
                }
            }

            // Update crabs
            crabs = crabs.filter(crab => {
                const alive = crab.update(dt);

                // Damage castle
                if (crab.atCastle && !crab.stunned && !crab.fleeing) {
                    castleHP -= 5 * dt;
                    if (castleHP <= 0) {
                        castleHP = 0;
                        gameOver();
                    }
                }

                return alive;
            });

            // Update wave timer
            if (!waveAnimating) {
                timeSinceLastWave += dt;
            }

            // Check if wave complete (10 second timer, and all enemies dead if it's a shop wave)
            if (!waveAnimating && timeSinceLastWave >= 10) {
                // If it's a shop wave (7, 14, 21, etc.), wait for all enemies to be killed
                if ((currentWave + 1) % 7 === 0 && crabs.length > 0) {
                    // Don't start next wave yet - enemies still alive on shop wave
                } else {
                    startNextWave();
                }
            }

            // Update objects and despawn if underwater (unless being dragged)
            const wavePos = calculateWavePositions();
            const currentWaveY = wavePos.darkBlueY; // Use the dark water layer as despawn threshold

            objects = objects.filter(obj => {
                obj.update(dt);
                // Don't despawn if being actively dragged
                if (draggedObjects.includes(obj)) return true;
                // Don't despawn if spawned by current wave (prevents immediate despawn)
                if (obj.spawnWave === currentWave) return true;
                // Despawn if underwater (wave covers it)
                return obj.y <= currentWaveY;
            });

            // Update particles
            particles = particles.filter(p => p.update(dt));

            // Update explosions
            explosions = explosions.filter(e => e.update(dt));

            // Update floating texts
            floatingTexts = floatingTexts.filter(ft => ft.update(dt));

            // Dragging (multi-tether support)
            if (draggedObjects.length > 0) {
                // Update each tethered object
                draggedObjects = draggedObjects.filter(obj => {
                    const dist = distance(mouse.x, mouse.y, obj.x, obj.y);

                    if (dist > 150) {
                        // Chain broke for this object
                        sounds.chainBreak();
                        return false; // Remove from tether array
                    }

                    // Lerp object toward mouse (slower speed for tethered items)
                    obj.x = lerp(obj.x, mouse.x, tetheredDragSpeed);
                    obj.y = lerp(obj.y, mouse.y, tetheredDragSpeed);
                    obj.baseY = obj.y;

                    // Check delivery (castle at top)
                    if (obj.y < 100 && obj.x > 100 && obj.x < GAME_WIDTH - 100) {
                        sandDollars += obj.value;
                        sounds.coin();
                        floatingTexts.push(new FloatingText(obj.x, obj.y, `+${obj.value} SD`, '#ffff00'));
                        objects = objects.filter(o => o !== obj);
                        return false; // Remove from tether array
                    }

                    return true; // Keep in tether array
                });
            }
        }

        function gameOver() {
            gameState = STATE.GAME_OVER;
            if (currentDay > highScore) {
                highScore = currentDay;
                localStorage.setItem('tidesOfWarHighScore', highScore);
            }
        }

        // ===== RENDER LOOP =====
        function render() {
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            if (gameState === STATE.START) {
                renderStartScreen();
            } else if (gameState === STATE.TUTORIAL || gameState === STATE.PLAYING || gameState === STATE.PAUSED) {
                renderGame();
                if (gameState === STATE.TUTORIAL) {
                    renderTutorial();
                } else if (gameState === STATE.PAUSED) {
                    renderPauseMenu();
                }
            } else if (gameState === STATE.SHOP) {
                renderGame();
                renderShop();
            } else if (gameState === STATE.GAME_OVER) {
                renderGame();
                renderGameOver();
            }
        }

        function renderStartScreen() {
            // Sky
            ctx.fillStyle = '#87ceeb';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Water
            ctx.fillStyle = '#6fb3d2';
            ctx.fillRect(0, GAME_HEIGHT * 0.4, GAME_WIDTH, GAME_HEIGHT * 0.6);

            // Simple wave animation
            const waveOffset = (Date.now() / 1000) % 1;
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 10; i++) {
                const x = (i / 10) * GAME_WIDTH + waveOffset * 100;
                ctx.fillRect(x, GAME_HEIGHT * 0.4, 20, 5);
            }

            // Title
            ctx.fillStyle = '#2d4a6e';
            ctx.font = 'bold 48px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('TIDES OF WAR', GAME_WIDTH/2, 200);

            // High score
            if (highScore > 0) {
                ctx.font = '16px "Press Start 2P"';
                ctx.fillText(`Best: Day ${highScore}`, GAME_WIDTH/2, 280);
            }

            // Start button
            const buttonX = GAME_WIDTH/2 - 100;
            const buttonY = 350;
            const buttonW = 200;
            const buttonH = 60;
            const hovered = mouse.x >= buttonX && mouse.x <= buttonX + buttonW &&
                           mouse.y >= buttonY && mouse.y <= buttonY + buttonH;

            ctx.fillStyle = hovered ? '#4a7c59' : '#3d6448';
            ctx.fillRect(buttonX, buttonY, buttonW, buttonH);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.strokeRect(buttonX, buttonY, buttonW, buttonH);

            ctx.fillStyle = '#fff';
            ctx.font = '24px "Press Start 2P"';
            ctx.fillText('START', GAME_WIDTH/2, buttonY + 40);

            // Tutorial checkbox
            const checkboxSize = 20;
            const checkboxX = GAME_WIDTH/2 - 80;
            const checkboxY = 450;
            const checkboxHovered = mouse.x >= checkboxX && mouse.x <= checkboxX + checkboxSize &&
                                    mouse.y >= checkboxY && mouse.y <= checkboxY + checkboxSize;

            // Checkbox border
            ctx.strokeStyle = checkboxHovered ? '#fff' : '#aaa';
            ctx.lineWidth = 2;
            ctx.strokeRect(checkboxX, checkboxY, checkboxSize, checkboxSize);

            // Checkbox fill if enabled
            if (tutorialEnabled) {
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(checkboxX + 4, checkboxY + 4, checkboxSize - 8, checkboxSize - 8);
            }

            // Checkbox label
            ctx.fillStyle = '#fff';
            ctx.font = '12px "Press Start 2P"';
            ctx.textAlign = 'left';
            ctx.fillText('Enable Tutorial', checkboxX + checkboxSize + 10, checkboxY + 15);

            // Decorative crabs
            ctx.fillStyle = '#ff6b4a';
            ctx.fillRect(950, 500, 40, 40);
            ctx.fillRect(200, 450, 30, 30);

            // Handle checkbox click
            if (mouse.clicked && checkboxHovered) {
                tutorialEnabled = !tutorialEnabled;
                localStorage.setItem('tidesOfWarTutorialEnabled', tutorialEnabled);
                sounds.button();
            }

            // Handle start button click
            if (mouse.clicked && hovered) {
                sounds.button();
                startNewGame();
            }
        }

        function renderGame() {
            // Get current wave positions
            const wavePos = calculateWavePositions();
            const activeFoamOffset = waveConfig.foamOffset * wavePos.currentCompression;
            const activeLightOffset = waveConfig.lightBlueOffset * wavePos.currentCompression;

            // Background - dry sand
            ctx.fillStyle = '#d2b48c';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            // Wet sand layer with gradient effect
            let wetSandY = wavePos.peakY;
            let wetSandFill;

            if (wavePos.isSurging) {
                // During surge - solid wet sand color
                wetSandY = wavePos.surgeY;
                wetSandFill = '#B08D55'; // Wet sand color
            } else {
                // After surge - gradient that dries over time
                const totalDuration = waveConfig.surgeDuration + waveConfig.expansionDuration + waveConfig.retreatFoamDuration;
                const dryingTimeTotal = totalDuration - waveConfig.surgeDuration;
                const timeSincePeak = waveAnimating ? (waveAnimTimer - waveConfig.surgeDuration) : dryingTimeTotal;
                const dryingProgress = Math.min(1, timeSincePeak / dryingTimeTotal);
                const dryLine = Math.pow(dryingProgress, 3);

                const gradient = ctx.createLinearGradient(0, wavePos.peakY, 0, GAME_HEIGHT);
                gradient.addColorStop(0, '#d2b48c'); // Dry sand at top
                gradient.addColorStop(Math.max(0, dryLine - 0.1), '#d2b48c');
                gradient.addColorStop(Math.min(1, dryLine + 0.2), '#B08D55'); // Wet sand
                gradient.addColorStop(1, '#B08D55');
                wetSandFill = gradient;
            }

            drawWavyLayer(wetSandFill, wetSandY, activeFoamOffset, 1.1, 1.5);

            // Top-down medieval sand castle - full width
            const castleW = GAME_WIDTH;
            const castleH = 100;
            const castleX = 0;
            const castleY = 0;

            // Sandy castle wall base
            ctx.fillStyle = '#d2b48c'; // Sand color
            ctx.fillRect(castleX, castleY, castleW, castleH);

            // Wall texture (darker sand)
            ctx.fillStyle = '#c4a574';
            ctx.fillRect(castleX, castleY, castleW, 15); // Top wall
            ctx.fillRect(castleX, castleY + castleH - 15, castleW, 15); // Bottom wall

            // Corner towers (circular, top-down view)
            const towerRadius = 40;
            ctx.fillStyle = '#b8956a';
            // Top-left tower
            ctx.beginPath();
            ctx.arc(towerRadius, castleY + 50, towerRadius, 0, Math.PI * 2);
            ctx.fill();
            // Top-right tower
            ctx.beginPath();
            ctx.arc(castleW - towerRadius, castleY + 50, towerRadius, 0, Math.PI * 2);
            ctx.fill();

            // Shell decorations on walls
            ctx.fillStyle = '#f5deb3'; // Wheat/shell color
            for (let i = 0; i < 20; i++) {
                const x = (i * (castleW / 20)) + (castleW / 40);
                // Top shells
                ctx.fillRect(x - 5, castleY + 5, 10, 8);
                // Bottom shells
                ctx.fillRect(x - 5, castleY + castleH - 13, 10, 8);
            }

            // Gate/entrance in center
            ctx.fillStyle = '#8b7355';
            ctx.fillRect(castleW/2 - 40, castleY + 30, 80, 40);

            // Objects
            const hoveredObj = objects.find(obj => obj.isHovered(mouse.x, mouse.y));
            objects.forEach(obj => {
                if (!draggedObjects.includes(obj)) {
                    obj.draw(ctx, obj === hoveredObj);
                }
            });

            // Crabs (Z-ordered)
            const sortedCrabs = [...crabs].sort((a, b) => a.y - b.y);
            sortedCrabs.forEach(crab => crab.draw(ctx));

            // Multi-layer wave system
            // Use interpolated water colors for smooth day/night transitions
            const baseWaterColor = rgbToHex(currentWaterColorRGB);

            // Lighten the base water color for the light blue layer
            const lightBlueColor = `rgb(${Math.min(255, currentWaterColorRGB.r + 80)}, ${Math.min(255, currentWaterColorRGB.g + 100)}, ${Math.min(255, currentWaterColorRGB.b + 120)})`;
            const foamColor = '#F0F8FF';

            // Draw resting ocean layers (use previous position to prevent jump)
            const restingOceanY = waveAnimating ? previousRestingY : wavePos.restingY;
            drawWavyLayer(foamColor, restingOceanY, waveConfig.foamOffset, 1.1, 1.5);
            drawWavyLayer(lightBlueColor, restingOceanY, waveConfig.lightBlueOffset, 1.05, 0.5);
            drawWavyLayer(baseWaterColor, restingOceanY, 0, 1.0, 0.0);

            // Draw moving surge/retreat layers (covers objects and crabs when submerged)
            if (waveAnimating) {
                drawWavyLayer(foamColor, wavePos.foamY, activeFoamOffset, 1.1, 1.5);
                drawWavyLayer(lightBlueColor, wavePos.lightBlueY, activeLightOffset, 1.05, 0.5);
                drawWavyLayer(baseWaterColor, wavePos.darkBlueY, 0, 1.0, 0.0);
            }

            // Dragged objects with chains
            if (draggedObjects.length > 0) {
                draggedObjects.forEach(obj => {
                    // Chain
                    ctx.strokeStyle = '#8b7355';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(mouse.x, mouse.y);
                    ctx.lineTo(obj.x, obj.y);
                    ctx.stroke();

                    // Draw segments
                    const dist = distance(mouse.x, mouse.y, obj.x, obj.y);
                    const segments = Math.floor(dist / 10);
                    for (let i = 0; i < segments; i++) {
                        const t = i / segments;
                        const x = lerp(mouse.x, obj.x, t);
                        const y = lerp(mouse.y, obj.y, t);
                        ctx.fillStyle = '#654321';
                        ctx.fillRect(x - 2, y - 2, 4, 4);
                    }

                    obj.draw(ctx, true);
                });
            }

            // Particles
            particles.forEach(p => p.draw(ctx));

            // Explosions
            explosions.forEach(e => e.draw(ctx));

            // Floating texts
            floatingTexts.forEach(ft => ft.draw(ctx));

            // HUD
            renderHUD();

            // Cursor
            if (gameState === STATE.PLAYING || gameState === STATE.TUTORIAL) {
                if (hoveredObj && draggedObjects.length === 0) {
                    canvas.style.cursor = 'grab';
                } else {
                    canvas.style.cursor = 'none';

                    // Blast radius circle
                    if (draggedObjects.length === 0) {
                        ctx.strokeStyle = cannonCooldown > 0 ? '#ff0000' : '#00ff00';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(mouse.x, mouse.y, blastRadius, 0, Math.PI * 2);
                        ctx.stroke();

                        // Ultimate charge circle (segmented circle slightly outside blast radius)
                        const ultRadius = blastRadius + 10;
                        const chargePercent = ultimateCharge / ultimateMaxCharge;

                        if (chargePercent >= 1) {
                            // Ultimate ready - solid yellow circle (no segments)
                            ctx.fillStyle = '#ffff00';
                            ctx.beginPath();
                            ctx.arc(mouse.x, mouse.y, ultRadius, 0, Math.PI * 2);
                            ctx.arc(mouse.x, mouse.y, ultRadius - 2, 0, Math.PI * 2, true);
                            ctx.closePath();
                            ctx.fill();
                        } else {
                            // Draw segmented circle (thinner)
                            const segmentAngle = (Math.PI * 2) / ultimateMaxCharge;

                            for (let i = 0; i < ultimateMaxCharge; i++) {
                                const startAngle = -Math.PI / 2 + (i * segmentAngle);
                                const endAngle = startAngle + segmentAngle - 0.1; // Small gap between segments

                                if (i < ultimateCharge) {
                                    // Charged segments - white
                                    ctx.fillStyle = '#ffffff';
                                } else {
                                    // Uncharged segments - transparent/dark
                                    ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                                }

                                ctx.beginPath();
                                ctx.arc(mouse.x, mouse.y, ultRadius, startAngle, endAngle);
                                ctx.arc(mouse.x, mouse.y, ultRadius - 2, endAngle, startAngle, true);
                                ctx.closePath();
                                ctx.fill();
                            }
                        }

                        // Crosshair
                        ctx.fillStyle = ctx.strokeStyle;
                        ctx.fillRect(mouse.x - 5, mouse.y - 1, 10, 2);
                        ctx.fillRect(mouse.x - 1, mouse.y - 5, 2, 10);
                    }
                }
            } else {
                canvas.style.cursor = 'default';
            }
        }

        function renderHUD() {
            const hudHeight = 50;

            // HUD background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, GAME_WIDTH, hudHeight);

            ctx.font = '14px "Press Start 2P"';
            ctx.fillStyle = '#fff';

            // Day counter (upper left)
            ctx.textAlign = 'left';
            ctx.fillText(`Day ${currentDay}`, 20, 30);

            // Castle HP (centered)
            ctx.textAlign = 'center';
            ctx.fillText('HP:', GAME_WIDTH/2 - 120, 30);

            const hpBarX = GAME_WIDTH/2 - 80;
            const hpBarW = 200;
            const hpBarH = 20;

            ctx.fillStyle = '#333';
            ctx.fillRect(hpBarX, 15, hpBarW, hpBarH);

            const hpPercent = castleHP / maxCastleHP;
            ctx.fillStyle = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffff00' : '#ff0000';
            ctx.fillRect(hpBarX, 15, hpBarW * hpPercent, hpBarH);

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(hpBarX, 15, hpBarW, hpBarH);

            // Money counter (upper right)
            ctx.fillStyle = '#ffd700';
            ctx.textAlign = 'right';
            ctx.fillText(`${sandDollars} SD`, GAME_WIDTH - 20, 30);

        }

        function renderTutorial() {
            const messages = [
                "Drag objects to your castle for Sand Dollars!",
                "Click to fire cannonballs at crabs!",
                "Press SPACEBAR when charged for Ultimate!",
                "Protect your castle from crabs!",
                "Visit the shop every 7 waves!"
            ];

            if (tutorialStep < messages.length) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(GAME_WIDTH/2 - 400, GAME_HEIGHT - 150, 800, 100);

                ctx.fillStyle = '#fff';
                ctx.font = '16px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(messages[tutorialStep], GAME_WIDTH/2, GAME_HEIGHT - 100);

                ctx.font = '12px "Press Start 2P"';
                ctx.fillText("Click anywhere to continue", GAME_WIDTH/2, GAME_HEIGHT - 70);
            } else {
                gameState = STATE.PLAYING;
                localStorage.setItem('tidesOfWarTutorial', 'true');
                tutorialShown = true;
            }
        }

        function renderShop() {
            // Overlay
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 100, GAME_WIDTH, GAME_HEIGHT - 100);

            // Title
            ctx.fillStyle = '#ffd700';
            ctx.font = '32px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('LOW TIDE - UPGRADE TIME!', GAME_WIDTH/2, 160);

            const upgradeList = [
                {name: 'cannonCooldown', display: 'Cannon Cooldown', desc: '-0.15s per tier'},
                {name: 'blastRadius', display: 'Blast Radius', desc: '+15px per tier'},
                {name: 'castleHealth', display: 'Castle Health', desc: '+30 HP (heals)'},
                {name: 'ultimateCharge', display: 'Ultimate Charge', desc: '-1 hit per tier'},
                {name: 'ultimateDamage', display: 'Ultimate Damage', desc: '+10 dmg per tier'},
                {name: 'dragSpeed', display: 'Drag Speed', desc: '+5% per tier'},
                {name: 'objectValue', display: 'Object Value', desc: '+20% per tier'},
                {name: 'maxTethers', display: 'Multi-Tether', desc: '+1 tether per tier'}
            ];

            const cols = 3;
            const cardW = 250;
            const cardH = 110;
            const spacing = 15;
            const startX = (GAME_WIDTH - (cardW * cols + spacing * 2)) / 2;
            const startY = 200;

            ctx.font = '12px "Press Start 2P"';

            upgradeList.forEach((upgrade, idx) => {
                const col = idx % cols;
                const row = Math.floor(idx / cols);
                const x = startX + col * (cardW + spacing);
                const y = startY + row * (cardH + spacing);

                const tier = upgrades[upgrade.name];
                const cost = Math.floor(20 * Math.pow(1.8, tier));
                const maxed = tier >= 5;
                const canAfford = sandDollars >= cost && !maxed;

                const hovered = mouse.x >= x && mouse.x <= x + cardW &&
                               mouse.y >= y && mouse.y <= y + cardH;

                // Card background
                ctx.fillStyle = hovered && canAfford ? '#3d5a3d' : '#2d3d4a';
                ctx.fillRect(x, y, cardW, cardH);

                ctx.strokeStyle = canAfford ? '#00ff00' : '#666';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, cardW, cardH);

                // Title
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'left';
                ctx.fillText(upgrade.display, x + 10, y + 25);

                // Tier
                ctx.fillStyle = '#ffd700';
                ctx.fillText(`Tier ${tier}/5`, x + 10, y + 45);

                // Description
                ctx.fillStyle = '#aaa';
                ctx.font = '10px "Press Start 2P"';
                ctx.fillText(upgrade.desc, x + 10, y + 65);

                // Cost
                ctx.font = '12px "Press Start 2P"';
                if (maxed) {
                    ctx.fillStyle = '#888';
                    ctx.fillText('MAXED', x + 10, y + 90);
                } else {
                    ctx.fillStyle = canAfford ? '#00ff00' : '#ff0000';
                    ctx.fillText(`${cost} SD`, x + 10, y + 90);

                    // Buy button
                    const btnX = x + cardW - 80;
                    const btnY = y + cardH - 35;
                    const btnW = 70;
                    const btnH = 25;

                    ctx.fillStyle = canAfford ? (hovered ? '#00cc00' : '#009900') : '#555';
                    ctx.fillRect(btnX, btnY, btnW, btnH);

                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(btnX, btnY, btnW, btnH);

                    ctx.fillStyle = '#fff';
                    ctx.font = '10px "Press Start 2P"';
                    ctx.textAlign = 'center';
                    ctx.fillText('BUY', btnX + btnW/2, btnY + 17);

                    // Handle purchase
                    if (mouse.clicked && hovered && canAfford) {
                        purchaseUpgrade(upgrade.name);
                    }
                }

                ctx.font = '12px "Press Start 2P"';
            });

            // Continue button
            const contX = GAME_WIDTH/2 - 100;
            const contY = GAME_HEIGHT - 80;
            const contW = 200;
            const contH = 50;
            const contHovered = mouse.x >= contX && mouse.x <= contX + contW &&
                               mouse.y >= contY && mouse.y <= contY + contH;

            ctx.fillStyle = contHovered ? '#4a7c59' : '#3d6448';
            ctx.fillRect(contX, contY, contW, contH);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.strokeRect(contX, contY, contW, contH);

            ctx.fillStyle = '#fff';
            ctx.font = '20px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('CONTINUE', GAME_WIDTH/2, contY + 33);

            if (mouse.clicked && contHovered) {
                sounds.button();
                gameState = STATE.PLAYING;
                startNextWave();
            }
        }

        function renderPauseMenu() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            ctx.fillStyle = '#fff';
            ctx.font = '48px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('PAUSED', GAME_WIDTH/2, 200);

            const buttons = [
                {text: 'RESUME', action: () => { gameState = STATE.PLAYING; }},
                {text: 'RESTART', action: () => { startNewGame(); }},
                {text: 'MAIN MENU', action: () => { gameState = STATE.START; }}
            ];

            buttons.forEach((btn, idx) => {
                const y = 300 + idx * 80;
                const x = GAME_WIDTH/2 - 150;
                const w = 300;
                const h = 60;

                const hovered = mouse.x >= x && mouse.x <= x + w &&
                               mouse.y >= y && mouse.y <= y + h;

                ctx.fillStyle = hovered ? '#4a7c59' : '#3d6448';
                ctx.fillRect(x, y, w, h);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);

                ctx.fillStyle = '#fff';
                ctx.font = '20px "Press Start 2P"';
                ctx.fillText(btn.text, GAME_WIDTH/2, y + 38);

                if (mouse.clicked && hovered) {
                    sounds.button();
                    btn.action();
                }
            });
        }

        function renderGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            ctx.fillStyle = '#ff6b6b';
            ctx.font = '48px "Press Start 2P"';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', GAME_WIDTH/2, 200);

            ctx.fillStyle = '#fff';
            ctx.font = '20px "Press Start 2P"';
            ctx.fillText(`Days Survived: ${currentDay}`, GAME_WIDTH/2, 280);

            if (currentDay === highScore) {
                ctx.fillStyle = '#ffd700';
                ctx.fillText('NEW HIGH SCORE!', GAME_WIDTH/2, 320);
            }

            const buttons = [
                {text: 'RESTART', action: () => { startNewGame(); }},
                {text: 'MAIN MENU', action: () => { gameState = STATE.START; }}
            ];

            buttons.forEach((btn, idx) => {
                const y = 420 + idx * 80;
                const x = GAME_WIDTH/2 - 150;
                const w = 300;
                const h = 60;

                const hovered = mouse.x >= x && mouse.x <= x + w &&
                               mouse.y >= y && mouse.y <= y + h;

                ctx.fillStyle = hovered ? '#4a7c59' : '#3d6448';
                ctx.fillRect(x, y, w, h);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);

                ctx.fillStyle = '#fff';
                ctx.font = '20px "Press Start 2P"';
                ctx.fillText(btn.text, GAME_WIDTH/2, y + 38);

                if (mouse.clicked && hovered) {
                    sounds.button();
                    btn.action();
                }
            });
        }

        // ===== MAIN GAME LOOP =====
        let lastTime = performance.now();

        function gameLoop(currentTime) {
            const dt = Math.min((currentTime - lastTime) / 1000, 0.1);
            lastTime = currentTime;

            // Handle input
            if (gameState === STATE.PLAYING || gameState === STATE.TUTORIAL) {
                if (mouse.clicked) {
                    if (gameState === STATE.TUTORIAL) {
                        tutorialStep++;
                        mouse.clicked = false;
                    } else {
                        // Fire cannon FIRST, then check for tethering
                        if (draggedObjects.length === 0) {
                            fireCannonball();
                        }

                        // Then check for tethering (happens after cannon fires)
                        if (draggedObjects.length === 0 && mouse.down) {
                            checkTetherObjects();
                        }
                    }
                }
            }

            // Auto-tether when mouse is held
            if (gameState === STATE.PLAYING && mouse.down && draggedObjects.length < maxTethers) {
                // Check if any objects are in cannon radius
                objects.forEach(obj => {
                    // Only tether if not already tethered and within blast radius
                    if (!draggedObjects.includes(obj) &&
                        draggedObjects.length < maxTethers &&
                        distance(mouse.x, mouse.y, obj.x, obj.y) <= blastRadius) {
                        draggedObjects.push(obj);
                        sounds.pickup();
                    }
                });
            }

            // Update
            if (gameState === STATE.PLAYING || gameState === STATE.TUTORIAL) {
                update(dt);
            }

            // Render
            render();

            // Reset click after render so UI can detect it
            mouse.clicked = false;

            requestAnimationFrame(gameLoop);
        }

        // Start the game
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>